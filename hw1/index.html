<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Your Project Title</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
            background-image: url('https://www.toptal.com/designers/subtlepatterns/uploads/skyscraper.png');
        }
        .navbar {
            background-color: #333;
            overflow: hidden;
        }
        .navbar a {
            float: left;
            display: block;
            color: white;
            text-align: center;
            padding: 14px 20px;
            text-decoration: none;
        }
        .navbar a:hover {
            background-color: #ddd;
            color: black;
        }
        .container {
            padding: 20px;
        }
        .content {
            background-color: #ffffff;
            background-image: url('https://www.toptal.com/designers/subtlepatterns/patterns/diagonal-striped-brick.png'); /* Adding texture to content background */
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .footer {
            text-align: center;
            padding: 20px;
            background-color: #333;
            color: white;
            margin-top: 20px;
        }
        h1, h2 {
            color: #333;
        }
        img {
            max-width: 100%;
            height: auto;
        }
        .question::before {
        content: "• ";
        font-weight: bold;
        }
        .question p {
        display: inline;
        font-weight: bold;
        }
        .image-container {
            display: flex; /* Use flexbox */
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
            height: 100vh; /* Make the container take the full height of the viewport */
            width: 100%; /* Ensure the container is full width */
        }
        .responsive-image {
            max-width: 100%; /* Make the image responsive */
            max-height: 80vh; /* Limit the image's height to ensure it fits within the viewport */
            height: auto; /* Maintain aspect ratio */
        }
</style>

    </style>
</head>
<body>

<div class="navbar">
    <a href="#home">Home</a>
    <a href="#task1">Task 1</a>
    <a href="#task2">Task 2</a>
    <a href="#task2">Task 3</a>
    <a href="#task2">Task 4</a>
    <a href="#task2">Task 5</a>
    <a href="#task2">Task 6</a>
</div>

<div class="container">
    <div class="content">
        <h1>Hi! Welcome to My CS 184 Project 1 :)</h1>
        
        <h2 id="task1">Task 1</h2>
        <div class="question"><p>Walk through how you rasterize triangles in your own words.</p></div>
        <p>First, we find the maximum and minimum values of x and y to determine the bounding box of the triangle. Then, we iterate through every pixel within the bounding box and check if it's inside the triangle. Here we check for two cases: the triangle winding is counter-clockwise and the triangle winding is clockwise, since we’re unsure which case it belongs to. For both cases, we apply a point-in-triangle (or three-line test) to see if it’s in the triangle. If it passes the test in one of the cases, then the point must be inside the triangle and we rasterize the point. </p>
        <div class="question"><p>Explain how your algorithm is no worse than one that checks each sample within the bounding box of the triangle.</p></div>
        <p>Essentially, our method does precisely that—it checks each sample within the bounding box. So, it's on par with any algorithm that adopts this approach.</p>
        <div class="question"><p>Show a png screenshot of basic/test4.svg with the default viewing parameters and with the pixel inspector centered on an interesting part of the scene.</p></div>
        <div class="image-container">
            <img src="images/task1.png" alt="Screenshot of basic/test4.svg" class="responsive-image">
        </div>

        
        <h2 id="task2">Task 2</h2>
        <div class="question"><p>Walk through your supersampling algorithm and data structures. Why is supersampling useful? What modifications did you make to the rasterization pipeline in the process? Explain how you used supersampling to antialias your triangles.</p></div>
        <p>Change in Data Structure: Expand the size of sample_buffer by multiplying it by the sample rate to store colour values for each sub-pixel. The indexing changes from sample_buffer [y * width + x] to sample_buffer[(((y * sqr_rate + dy) * width * sqr_rate) + x * sqr_rate + dx)], where sqr_rate = sqrt(sample_rate).</p>
        <p>Algorithm: Taking the sample rate of 4 as an example, whenever rendering a triangle in rasterize_triangle(), I break each pixel within the bounding box into 4 smaller rectangles and pass each sub-part to the triangle test. The point for each sub-part is now (x + 1/(2*sqr_rate) + xd*1/sqr_rate, y + 1/(2*sqr_rate) + yd*1/sqr_rate), where xd and yd is the index of 4 sub-parts. If the point passes the triangle test, we index it into sample_buffer and store its corresponding colour.</p>
        <p>In resolve_to_framebuffer(), we calculate the average colour value from all 4 subparts of each pixel and transfer the corresponding average colour to rgb_framebuffer_target.</p>
        <p>Why helpful: It reduces sampling artifacts like jaggies and makes the line smooth by averaging multiple samples for each pixel and making diagonal lines and curves appear more natural and less pixelated.</p>
        
        <div class="question"><p>Show png screenshots of basic/test4.svg with the default viewing parameters and sample rates 1, 4, and 16 to compare them side-by-side. Position the pixel inspector over an area that showcases the effect dramatically; for example, a very skinny triangle corner. Explain why these results are observed.</p></div>
        <div class="image-comparison-container">
            <img src="images/task2-1.png" alt="Sample Rate 1" class="responsive-image">
            <img src="images/task2-2.png" alt="Sample Rate 4" class="responsive-image">
            <img src="images/task2-3.png" alt="Sample Rate 16" class="responsive-image">
        </div>
        <p>Observation: From left to right: 1, 4, 16. It's evident that as we increase the sampling rate, the number of jaggies decreases, and the line appears smoother. This is because rather than simply categorizing each pixel as either "passing" or "failing" the line test, we now compute the average colour value of the samples within a pixel. This method introduces a more gradual transition in colour, resulting in enhanced smoothness and reduced sampling artifacts.</p>


    
    </div>
</div>

<div class="footer">
    <p>Alina Sheng & Xiaowen Liu</p>
</div>

</body>
</html>
